// main.cpp

#include "gui/graphVisualizer.h"
#include "algorithms/geneticAlgorithm.h"
#include "WOCAlgorithm.h"
#include "utilities/randomWeightedGraph.h"
#include "utilities/globalData.h"
#include "common.h"
#include <iostream>

int main() {
    Timer timer;

    std::cout << "How many vertices would you like? ";
    std::cin >> n;
    if (n <= 0) {
        std::cerr << "Wrong input." << std::endl;
        exit(1);
    }


    randomWeightedGraph graph;
    graph.generateGraph();

    // Access the global variables directly
    std::cout << "\nNumber of vertices: " << n << "\n";
    std::cout << "Number of terminal vertices: " << numTerminals << "\n";

    // Display the vertices
    std::cout << "\nVertices:\n";
    for (const auto &vertex: vertices) {
        int id = static_cast<int>(vertex[0]);
        double x = vertex[1];
        double y = vertex[2];
        bool isTerminal = vertex[3] == 1.0;
        std::cout << "Vertex " << id << ": (" << x << ", " << y << ")";
        if (isTerminal) {
            std::cout << " [Terminal]";
        }
        std::cout << "\n";
    }

    // Display the edges
    std::cout << "\nEdges:\n";
    for (const auto &edge: edges) {
        std::cout << "Edge from " << edge.vertexA << " to " << edge.vertexB
                  << " with weight " << edge.weight << "\n";
    }

    int populationSize = 50;
    int generations = 1000;

    // Get user input for population size
    std::cout << "Enter population size: ";
    std::cin >> populationSize;

    // Get user input for number of generations
    std::cout << "Enter number of generations: ";
    std::cin >> generations;




    // Output the time taken
    std::cout << "\nTime taken to execute randomSteinerTree: "
              << timer.elapsedMilliseconds() << " ms\n" << std::endl;

    SteinerTree tree = randomSteinerTree();

    timer.start();
    std::vector<SteinerTree> best = runGeneticAlgorithm(populationSize, generations);
    timer.stop();

    // Output the time taken
    std::cout << "\nTime taken to execute randomSteinerTree: "
              << timer.elapsedMilliseconds() << " ms\n" << std::endl;
    int x = 0;
    for(double num : avgDistanceOverGenerations) {
        std::cout << num << " " << x << std::endl;
        x++;
    }

    printEdges();
    WOCAlgorithm wocAlgorithm;

    Strategy selectedStrategy = Strategy::Threshold;

    SteinerTree bestWOCTree = wocAlgorithm.generateSteinerTree(selectedStrategy);

    printSteinerTree(bestWOCTree);

    // Initialize and display the graph visualization GUI
    graphVisualizer visualizer;
    visualizer.displayPlot(best[0], bestWOCTree);

    return 0;
}


// geneticAlgorithm.cpp
// Created by LuisF on 11/14/2024.

#include "geneticAlgorithm.h"
#include "globalData.h"
#include "common.h"
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <random>
#include <algorithm>
#include <iostream>




#include <iostream>
#include <vector>
#include <unordered_set>
#include <random>
#include <algorithm>

// Global variables representing the graph
const int MAXN = 100;
std::vector<int> adj[MAXN]; // Adjacency list representation of the graph

// Randomly selects a starting vertex from the terminalVertices
int getRandomStart() {
    // Initialize random number generator
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, n);

    // Return a random number between 1 and n
    return dis(gen);
}


std::vector<int> removeConsecutiveDuplicates(const std::vector<int>& path) {
    if (path.empty()) return {};

    std::vector<int> finalPath;
    finalPath.push_back(path[0]);

    for (size_t i = 1; i < path.size(); ++i) {
        // Add the current city if it's not a consecutive duplicate
        if (path[i] != path[i - 1]) {
            finalPath.push_back(path[i]);
        }

        // Check if we can remove the last two cities due to backtracking
        if (i >= 2) {
            // Current city
            int current = path[i];
            // City two steps back
            int twoBack = path[i - 2];
            // City one step back
            int oneBack = path[i - 1];

            // Check if current city equals two steps back
            // and both current and oneBack are non-terminal
            if (current == twoBack &&
                terminalVertices.find(current) == terminalVertices.end() &&
                terminalVertices.find(oneBack) == terminalVertices.end()) {

                // Remove the last city (oneBack) from finalPath
                finalPath.pop_back();

                // Do not add the current city to avoid backtracking
                // Thus, finalPath remains up to twoBack
            }
        }
    }

    return finalPath;
}


// Function to perform DFS to find a valid Steiner tree
SteinerTree randomSteinerTree() {
    const int MAX_ITERATIONS = 100000; // Maximum allowed iterations before restarting

    std::random_device rd;
    std::mt19937 gen(rd());

    while (true) {
        int iterationCount = 0;

        std::unordered_set<int> visitedTerminals; // Track visited terminal vertices
        std::vector<int> visitedCities;           // Track all cities visited (with duplicates)
        std::vector<EdgeInfo> availableEdges;     // Track available edges from the current city
        std::vector<int> finalPath;               // Write out the official path of the Steiner Tree

        // Choose a random starting vertex from terminal vertices
        int currentCity = getRandomStart();

        while (true) {
            iterationCount++;

            // Add the current city to the visited list
            visitedCities.push_back(currentCity);

            // If the current city is a terminal vertex, add it to the visited terminals set
            if (terminalVertices.count(currentCity)) {
                visitedTerminals.insert(currentCity);
            }

            // Gather all available edges connected to the current city
            availableEdges.clear();
            for (const auto& edge : edges) {
                if (edge.vertexA == currentCity || edge.vertexB == currentCity) {
                    availableEdges.push_back(edge);
                }
            }

            // If no more available edges, break the loop
            if (availableEdges.empty()) {
                break;
            }

            // Randomly pick an edge from the available edges
            std::uniform_int_distribution<> dis(0, availableEdges.size() - 1);
            EdgeInfo chosenEdge = availableEdges[dis(gen)];

            // Determine the next city to visit based on the chosen edge
            int nextCity = (chosenEdge.vertexA == currentCity) ? chosenEdge.vertexB : chosenEdge.vertexA;

            currentCity = nextCity; // Move to the next city

            // Stop if all terminal vertices are visited
            if (visitedTerminals.size() == terminalVertices.size()) {
                finalPath = removeConsecutiveDuplicates(visitedCities);

                double totalLength = computeTotalDistance(finalPath);
                SteinerTree tree = {finalPath, totalLength};
                return tree;

            }

            // If maximum iterations reached, restart the function
            if (iterationCount >= MAX_ITERATIONS) {
                std::cerr << "Maximum iterations reached. Restarting the traversal." << std::endl;
                break; // Break out of the inner while loop to restart
            }
        }

        // If we haven't returned by now, we need to restart
        // Continue the outer while loop to restart the traversal
    }
}

// Function to perform crossover between two Steiner trees
SteinerTree crossoverFunction(const SteinerTree &parentA, const SteinerTree &parentB) {
    // Initialize random number generator
    std::random_device rd;
    std::mt19937 gen(rd());

    // Ensure parents have paths
    if (parentA.path.empty() || parentB.path.empty()) {
        // Return the non-empty parent or an empty tree
        return parentA.path.empty() ? parentB : parentA;
    }

    // Step 1: Find valid crossover points where the nodes are connected
    std::vector<size_t> validCrossoverPointsA;
    std::vector<size_t> validCrossoverPointsB;

    // Build sets for faster lookup
    std::unordered_set<int> parentA_nodes(parentA.path.begin(), parentA.path.end());
    std::unordered_set<int> parentB_nodes(parentB.path.begin(), parentB.path.end());

    // Find all nodes common to both parents
    std::vector<int> commonNodes;
    for (int node : parentA_nodes) {
        if (parentB_nodes.count(node)) {
            commonNodes.push_back(node);
        }
    }

    // If there are common nodes, use them as crossover points
    if (!commonNodes.empty()) {
        // Randomly select a common node as the crossover point
        std::uniform_int_distribution<> disCommon(0, commonNodes.size() - 1);
        int crossoverNode = commonNodes[disCommon(gen)];

        // Find indices of the crossover node in both parents
        auto itA = std::find(parentA.path.begin(), parentA.path.end(), crossoverNode);
        auto itB = std::find(parentB.path.begin(), parentB.path.end(), crossoverNode);

        size_t indexA = std::distance(parentA.path.begin(), itA);
        size_t indexB = std::distance(parentB.path.begin(), itB);

        // Create offspring by combining the subpaths at the crossover node
        std::vector<int> offspringPath;

        // Add subpath from parent A up to and including the crossover node
        offspringPath.insert(offspringPath.end(), parentA.path.begin(), parentA.path.begin() + indexA + 1);

        // Add subpath from parent B after the crossover node
        offspringPath.insert(offspringPath.end(), parentB.path.begin() + indexB + 1, parentB.path.end());

        // Repair the offspring path to ensure all terminals are included and edges exist
        offspringPath = repairPath(offspringPath);

        // Compute total distance
        double totalDistance = computeTotalDistance(offspringPath);

        return {offspringPath, totalDistance};
    } else {
        // No common nodes; find valid crossover points where nodes are connected by existing edges
        std::vector<std::pair<size_t, size_t>> connectedCrossoverPoints;

        for (size_t i = 1; i < parentA.path.size(); ++i) {
            int nodeA = parentA.path[i];
            for (size_t j = 1; j < parentB.path.size(); ++j) {
                int nodeB = parentB.path[j];
                if (edgeExists(nodeA, nodeB)) {
                    connectedCrossoverPoints.emplace_back(i, j);
                }
            }
        }

        if (!connectedCrossoverPoints.empty()) {
            // Randomly select a connected crossover point
            std::uniform_int_distribution<> disConnected(0, connectedCrossoverPoints.size() - 1);
            auto [indexA, indexB] = connectedCrossoverPoints[disConnected(gen)];

            // Create offspring by combining subpaths and connecting crossover points
            std::vector<int> offspringPath;

            // Add subpath from parent A up to indexA
            offspringPath.insert(offspringPath.end(), parentA.path.begin(), parentA.path.begin() + indexA + 1);

            // Add node from parent B at indexB to connect
            offspringPath.push_back(parentB.path[indexB]);

            // Add subpath from parent B after indexB
            offspringPath.insert(offspringPath.end(), parentB.path.begin() + indexB + 1, parentB.path.end());

            // Repair the offspring path
            offspringPath = repairPath(offspringPath);

            // Compute total distance
            double totalDistance = computeTotalDistance(offspringPath);

            return {offspringPath, totalDistance};
        } else {
            // If no valid crossover points, return one of the parents
            return (parentA.totalDistance < parentB.totalDistance) ? parentA : parentB;
        }
    }
}

// Function to perform random mutations on a vector of Steiner Trees
void randomMutation(std::vector<SteinerTree>& population, double mutationRate) {
    std::random_device rd;
    std::mt19937 gen(rd());

    for (auto& tree : population) {
        std::uniform_real_distribution<> dis(0.0, 1.0);
        if (dis(gen) < mutationRate) {
            // Apply mutation to this tree
            // Decide which mutation to apply
            std::uniform_int_distribution<> mutationTypeDis(1, 3);
            int mutationType = mutationTypeDis(gen);

            if (mutationType == 1) {
                // **Mutation Type 1:** Randomly remove a non-terminal node from the path
                std::vector<int> nonTerminalIndices;
                for (size_t i = 0; i < tree.path.size(); ++i) {
                    int node = tree.path[i];
                    if (terminalVertices.find(node) == terminalVertices.end()) {
                        nonTerminalIndices.push_back(i);
                    }
                }

                if (!nonTerminalIndices.empty()) {
                    std::uniform_int_distribution<> indexDis(0, nonTerminalIndices.size() - 1);
                    size_t idxToRemove = nonTerminalIndices[indexDis(gen)];

                    // Remove the node from the path
                    tree.path.erase(tree.path.begin() + idxToRemove);
                }

            } else if (mutationType == 2) {
                // **Mutation Type 2:** Randomly add a new non-terminal node into the path
                // Choose a random position to insert
                if (tree.path.size() >= 2) {
                    std::uniform_int_distribution<> posDis(1, tree.path.size() - 1);
                    size_t insertPos = posDis(gen);

                    // Choose a random non-terminal node not already in the path
                    std::unordered_set<int> nodesInPath(tree.path.begin(), tree.path.end());
                    std::vector<int> candidateNodes;
                    for (int i = 0; i < n; ++i) {
                        if (terminalVertices.find(i) == terminalVertices.end() && nodesInPath.find(i) == nodesInPath.end()) {
                            candidateNodes.push_back(i);
                        }
                    }

                    if (!candidateNodes.empty()) {
                        std::uniform_int_distribution<> candidateDis(0, candidateNodes.size() - 1);
                        int newNode = candidateNodes[candidateDis(gen)];

                        // Insert newNode at insertPos
                        tree.path.insert(tree.path.begin() + insertPos, newNode);
                    }
                }

            } else if (mutationType == 3) {
                // **Mutation Type 3:** Rewire a portion of the tree
                // Randomly select a segment of the path and reverse it
                if (tree.path.size() >= 4) {
                    std::uniform_int_distribution<> indexDis(1, tree.path.size() - 2);
                    size_t startIdx = indexDis(gen);
                    size_t endIdx = indexDis(gen);

                    if (startIdx > endIdx) std::swap(startIdx, endIdx);

                    // Reverse the segment between startIdx and endIdx
                    std::reverse(tree.path.begin() + startIdx, tree.path.begin() + endIdx + 1);
                }
            }

            // After mutation, ensure all terminals are in the path
            std::unordered_set<int> pathSet(tree.path.begin(), tree.path.end());
            for (int terminal : terminalVertices) {
                if (pathSet.find(terminal) == pathSet.end()) {
                    // Find the closest node in the current path to connect the missing terminal
                    int closestNode = -1;
                    double minDistance = std::numeric_limits<double>::max();
                    for (int node : pathSet) {
                        double dx = vertices[node][1] - vertices[terminal][1];
                        double dy = vertices[node][2] - vertices[terminal][2];
                        double dist = std::sqrt(dx * dx + dy * dy);
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestNode = node;
                        }
                    }
                    // Insert the terminal after the closest node
                    auto it = std::find(tree.path.begin(), tree.path.end(), closestNode);
                    if (it != tree.path.end()) {
                        tree.path.insert(it + 1, terminal);
                    } else {
                        // If closest node not found (shouldn't happen), append at the end
                        tree.path.push_back(terminal);
                    }
                }
            }

            // Remove consecutive duplicates and recompute the total distance
            tree.path = removeConsecutiveDuplicates(tree.path);
            tree.totalDistance = computeTotalDistance(tree.path);
        }
    }
}

std::vector<SteinerTree> initialPopulation (int size) {
    std::vector<SteinerTree> initialPopulation;

    // Progress milestones
    int milestone25 = size * 0.25;
    int milestone50 = size * 0.50;
    int milestone75 = size * 0.75;
    int milestone90 = size * 0.90;

    for (int i = 0; i < size; i++) {
        initialPopulation.push_back(randomSteinerTree());

        // Print progress at milestones
        if (i == milestone25) {
            std::cout << "25% of the initial population generated." << std::endl;
        } else if (i == milestone50) {
            std::cout << "50% of the initial population generated." << std::endl;
        } else if (i == milestone75) {
            std::cout << "75% of the initial population generated." << std::endl;
        }
    }
    std::cout << "initial population generated.\n" << std::endl;
    return initialPopulation;
}

std::vector<SteinerTree> runGeneticAlgorithm(int populationSize, int generations) {
    std::vector<SteinerTree> parentPopulation = initialPopulation(populationSize);
    int p = parentPopulation.size();


    double minMutationRate = 0.01; // 1%
    double maxMutationRate = 0.5;  // 50%

    // Progress milestones
    int milestone25 = generations * 0.25;
    int milestone50 = generations * 0.50;
    int milestone75 = generations * 0.75;
    int milestone90 = generations * 0.90;

    int currentGeneration = 0;
    while(currentGeneration < generations) {
        avgDistanceOverGenerations.push_back(computeTotalDistanceOfPopulation(parentPopulation));

        // Adjust mutation rate based on generation
        double mutationRate;
        if (currentGeneration < generations / 2) {
            mutationRate = minMutationRate;
        } else {
            double progress = (currentGeneration - generations / 2) / static_cast<double>(generations / 2);
            mutationRate = minMutationRate + progress * (maxMutationRate - minMutationRate);
        }

        std::vector<SteinerTree> fitPopulation = selectTopK(parentPopulation);
        incrementEdgeFrequencies(fitPopulation);
        std::vector<SteinerTree> childPopulation;

        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, fitPopulation.size() - 1);

        while (childPopulation.size() < p) {
            int parentAIdx = dis(gen);
            int parentBIdx = dis(gen);

            // Ensure parents are different
            while (parentAIdx == parentBIdx) {
                parentBIdx = dis(gen);
            }

            // Create offspring using crossoverFunction
            SteinerTree offspring = crossoverFunction(fitPopulation[parentAIdx], fitPopulation[parentBIdx]);
            childPopulation.push_back(offspring);
        }

        // Mutation
//        randomMutation(childPopulation, mutationRate); // Using a 10% mutation rate

        // Prepare for next generation
        parentPopulation = childPopulation;

        // Print progress at milestones
        if (currentGeneration == milestone25) {
            std::cout << "25% of generations completed." << std::endl;
        } else if (currentGeneration == milestone50) {
            std::cout << "50% of generations completed." << std::endl;
        } else if (currentGeneration == milestone75) {
            std::cout << "75% of generations completed." << std::endl;
        }

        currentGeneration++;
    }

    std::cout << "generations completed.\n" << std::endl;
    return parentPopulation;
}


#include "WOCAlgorithm.h"
#include "common.h"
#include <algorithm>
#include <queue>
#include <stack>
#include <unordered_map>
#include <random>
#include <cmath>
#include <iostream>

// Public method to generate Steiner Tree based on selected strategy
SteinerTree WOCAlgorithm::generateSteinerTree(Strategy strategy) {
    switch (strategy) {
        case Strategy::MSTBased:
            return generateMSTBasedSteinerTree();
        case Strategy::SPH:
            return generateSPHSteinerTree();
        case Strategy::Probabilistic:
            return generateProbabilisticSteinerTree();
        case Strategy::IterativeAddition:
            return generateIterativeAdditionSteinerTree();
        case Strategy::Threshold:
            return generateThresholdSteinerTree();
        default:
            std::cerr << "Invalid strategy selected. Returning empty Steiner Tree." << std::endl;
            return {};
    }
}

/////////////////////////////////////////////////////////////////
// Method 1: Minimum Spanning Tree (MST) Based Algorithm
/////////////////////////////////////////////////////////////////

SteinerTree WOCAlgorithm::generateMSTBasedSteinerTree() {
    // Adjust edge weights based on frequencies
    std::vector<EdgeInfo> adjustedEdges = edges;
    for (auto& edge : adjustedEdges) {
        double freq = edge.frequency > 0 ? static_cast<double>(edge.frequency) : 1.0;
        edge.weight = edge.weight / freq;
    }

    // Sort edges by adjusted weight (ascending)
    std::sort(adjustedEdges.begin(), adjustedEdges.end(), [](const EdgeInfo& a, const EdgeInfo& b) {
        return a.weight < b.weight;
    });

    // Kruskal's algorithm to compute MST
    std::vector<int> parent(n);
    std::iota(parent.begin(), parent.end(), 0);

    auto find_set = [&](int u) -> int {
        while (parent[u] != u)
            u = parent[u];
        return u;
    };

    auto unite_set = [&](int u, int v) {
        int pu = find_set(u);
        int pv = find_set(v);
        if (pu != pv)
            parent[pu] = pv;
    };

    std::vector<EdgeInfo> mstEdges;
    for (const auto& edge : adjustedEdges) {
        int u = edge.vertexA;
        int v = edge.vertexB;
        if (find_set(u) != find_set(v)) {
            unite_set(u, v);
            mstEdges.push_back(edge);
        }
    }

    // Build adjacency list from MST edges
    std::unordered_map<int, std::vector<int>> graph;
    for (const auto& edge : mstEdges) {
        graph[edge.vertexA].push_back(edge.vertexB);
        graph[edge.vertexB].push_back(edge.vertexA);
    }

    // Prune non-terminal leaves
    bool removed = true;
    while (removed) {
        removed = false;
        std::vector<int> leaves;
        for (const auto& node : graph) {
            if (graph[node.first].size() == 1 && terminalVertices.find(node.first) == terminalVertices.end()) {
                leaves.push_back(node.first);
            }
        }
        for (int leaf : leaves) {
            if (graph.find(leaf) != graph.end()) {
                int neighbor = graph[leaf][0];
                graph[neighbor].erase(std::remove(graph[neighbor].begin(), graph[neighbor].end(), leaf), graph[neighbor].end());
                graph.erase(leaf);
                removed = true;
            }
        }
    }

    // Extract path using DFS
    std::vector<int> path;
    std::unordered_set<int> visited;
    std::stack<int> stackDFS;
    int start = *terminalVertices.begin();
    stackDFS.push(start);
    visited.insert(start);
    while (!stackDFS.empty()) {
        int current = stackDFS.top();
        stackDFS.pop();
        path.push_back(current);
        for (int neighbor : graph[current]) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                stackDFS.push(neighbor);
            }
        }
    }

    // Compute total distance
    double totalDistance = computeTotalDistance(path);

    return {path, totalDistance};
}

/////////////////////////////////////////////////////////////////
// Method 2: Shortest Path Heuristic (SPH) Algorithm
/////////////////////////////////////////////////////////////////

SteinerTree WOCAlgorithm::generateSPHSteinerTree() {
    // Adjust edge weights based on frequencies
    std::vector<EdgeInfo> adjustedEdges = edges;
    for (auto& edge : adjustedEdges) {
        double freq = edge.frequency > 0 ? static_cast<double>(edge.frequency) : 1.0;
        edge.weight = edge.weight / freq;
    }

    // Build adjacency list with adjusted weights
    std::unordered_map<int, std::vector<std::pair<int, double>>> graph;
    for (const auto& edge : adjustedEdges) {
        graph[edge.vertexA].emplace_back(edge.vertexB, edge.weight);
        graph[edge.vertexB].emplace_back(edge.vertexA, edge.weight);
    }

    // Compute shortest paths between all pairs of terminals using Dijkstra's algorithm
    std::unordered_map<int, std::unordered_map<int, std::vector<int>>> shortestPaths;
    for (int terminal : terminalVertices) {
        // Dijkstra's algorithm from terminal
        std::unordered_map<int, double> dist;
        std::unordered_map<int, int> prev;
        for (int i = 0; i < n; ++i)
            dist[i] = std::numeric_limits<double>::infinity();
        dist[terminal] = 0.0;

        // Priority queue: (distance, node)
        using pii = std::pair<double, int>;
        std::priority_queue<pii, std::vector<pii>, std::greater<pii>> pq;
        pq.emplace(0.0, terminal);

        while (!pq.empty()) {
            auto [currentDist, u] = pq.top();
            pq.pop();

            if (currentDist > dist[u])
                continue;

            for (const auto& [v, weight] : graph[u]) {
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    prev[v] = u;
                    pq.emplace(dist[v], v);
                }
            }
        }

        // Store paths to other terminals
        for (int t : terminalVertices) {
            if (t == terminal) continue;
            if (dist[t] == std::numeric_limits<double>::infinity()) continue; // No path
            std::vector<int> path;
            int current = t;
            while (current != terminal) {
                path.push_back(current);
                current = prev[current];
            }
            path.push_back(terminal);
            std::reverse(path.begin(), path.end());
            shortestPaths[terminal][t] = path;
        }
    }

    // Collect all terminal edges with their paths
    struct TerminalEdge {
        int u, v;
        double weight;
        std::vector<int> path;
    };
    std::vector<TerminalEdge> terminalEdges;
    for (int u : terminalVertices) {
        for (int v : terminalVertices) {
            if (u >= v) continue;
            if (shortestPaths[u].find(v) != shortestPaths[u].end()) {
                double weight = computeTotalDistance(shortestPaths[u][v]);
                terminalEdges.push_back({u, v, weight, shortestPaths[u][v]});
            }
        }
    }

    // Kruskal's algorithm on terminal edges
    std::sort(terminalEdges.begin(), terminalEdges.end(), [](const TerminalEdge& a, const TerminalEdge& b) {
        return a.weight < b.weight;
    });

    std::unordered_map<int, int> parent;
    for (int t : terminalVertices)
        parent[t] = t;

    auto find_set_sph = [&](int u) -> int {
        while (parent[u] != u)
            u = parent[u];
        return u;
    };

    auto unite_set_sph = [&](int u, int v) {
        parent[find_set_sph(u)] = find_set_sph(v);
    };

    std::vector<int> steinerPath;
    for (const auto& edge : terminalEdges) {
        if (find_set_sph(edge.u) != find_set_sph(edge.v)) {
            unite_set_sph(edge.u, edge.v);
            steinerPath.insert(steinerPath.end(), edge.path.begin(), edge.path.end());
        }
    }

    // Remove duplicates while preserving order
    std::vector<int> uniquePath;
    std::unordered_set<int> seen;
    for (int node : steinerPath) {
        if (seen.find(node) == seen.end()) {
            uniquePath.push_back(node);
            seen.insert(node);
        }
    }

    // Compute total distance
    double totalDistance = computeTotalDistance(uniquePath);

    return {uniquePath, totalDistance};
}

/////////////////////////////////////////////////////////////////
// Method 3: Probabilistic Edge Selection Algorithm
/////////////////////////////////////////////////////////////////

SteinerTree WOCAlgorithm::generateProbabilisticSteinerTree() {
    // Compute total frequency
    double totalFrequency = 0.0;
    for (const auto& edge : edges)
        totalFrequency += static_cast<double>(edge.frequency);

    if (totalFrequency == 0.0) {
        std::cerr << "All edge frequencies are zero. Cannot proceed with Probabilistic Algorithm." << std::endl;
        return {};
    }

    // Create cumulative distribution
    std::vector<double> cumulativeFreq;
    cumulativeFreq.push_back(0.0);
    for (const auto& edge : edges)
        cumulativeFreq.push_back(cumulativeFreq.back() + static_cast<double>(edge.frequency) / totalFrequency);

    // Initialize Union-Find structure
    std::vector<int> parentUF(n);
    std::iota(parentUF.begin(), parentUF.end(), 0);

    auto find_set_p = [&](int u) -> int {
        while (parentUF[u] != u)
            u = parentUF[u];
        return u;
    };

    auto unite_set_p = [&](int u, int v) {
        parentUF[find_set_p(u)] = find_set_p(v);
    };

    // Initialize graph
    std::unordered_map<int, std::vector<int>> graph;

    // Random number generator
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);

    // Select edges probabilistically
    while (true) {
        double r = dis(gen);
        auto it = std::lower_bound(cumulativeFreq.begin(), cumulativeFreq.end(), r);
        int index = std::distance(cumulativeFreq.begin(), it) - 1;
        if (index < 0 || index >= static_cast<int>(edges.size())) continue;

        const auto& edge = edges[index];
        int u = edge.vertexA;
        int v = edge.vertexB;

        if (find_set_p(u) != find_set_p(v)) {
            unite_set_p(u, v);
            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        // Check if all terminals are connected
        int parentTerminal = find_set_p(*terminalVertices.begin());
        bool allConnected = std::all_of(terminalVertices.begin(), terminalVertices.end(), [&](int t) {
            return find_set_p(t) == parentTerminal;
        });
        if (allConnected) break;
    }

    // Extract path using DFS
    std::vector<int> path;
    std::unordered_set<int> visited;
    std::stack<int> stackDFS;
    int start = *terminalVertices.begin();
    stackDFS.push(start);
    visited.insert(start);
    while (!stackDFS.empty()) {
        int current = stackDFS.top();
        stackDFS.pop();
        path.push_back(current);
        for (int neighbor : graph[current]) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                stackDFS.push(neighbor);
            }
        }
    }

    // Compute total distance
    double totalDistance = computeTotalDistance(path);

    return {path, totalDistance};
}

/////////////////////////////////////////////////////////////////
// Method 4: Iterative Edge Addition Algorithm
/////////////////////////////////////////////////////////////////

SteinerTree WOCAlgorithm::generateIterativeAdditionSteinerTree() {
    // Sort edges by frequency descending
    std::vector<EdgeInfo> sortedEdges = edges;
    std::sort(sortedEdges.begin(), sortedEdges.end(), [](const EdgeInfo& a, const EdgeInfo& b) {
        return a.frequency > b.frequency;
    });

    // Initialize Union-Find structure
    std::vector<int> parentUF(n);
    std::iota(parentUF.begin(), parentUF.end(), 0);

    auto find_set_i = [&](int u) -> int {
        while (parentUF[u] != u)
            u = parentUF[u];
        return u;
    };

    auto unite_set_i = [&](int u, int v) {
        parentUF[find_set_i(u)] = find_set_i(v);
    };

    // Initialize graph
    std::unordered_map<int, std::vector<int>> graph;

    // Add edges iteratively
    for (const auto& edge : sortedEdges) {
        int u = edge.vertexA;
        int v = edge.vertexB;
        if (find_set_i(u) != find_set_i(v)) {
            unite_set_i(u, v);
            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        // Check if all terminals are connected
        int parentTerminal = find_set_i(*terminalVertices.begin());
        bool allConnected = std::all_of(terminalVertices.begin(), terminalVertices.end(), [&](int t) {
            return find_set_i(t) == parentTerminal;
        });
        if (allConnected) break;
    }

    // Extract path using DFS
    std::vector<int> path;
    std::unordered_set<int> visited;
    std::stack<int> stackDFS;
    int start = *terminalVertices.begin();
    stackDFS.push(start);
    visited.insert(start);
    while (!stackDFS.empty()) {
        int current = stackDFS.top();
        stackDFS.pop();
        path.push_back(current);
        for (int neighbor : graph[current]) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                stackDFS.push(neighbor);
            }
        }
    }

    // Compute total distance
    double totalDistance = computeTotalDistance(path);

    return {path, totalDistance};
}

/////////////////////////////////////////////////
// Method 5: Edge Frequency Thresholding Algorithm
/////////////////////////////////////////////////

SteinerTree WOCAlgorithm::generateThresholdSteinerTree() {
    // Calculate mean frequency
    double totalFrequency = 0.0;
    for (const auto& edge : edges)
        totalFrequency += static_cast<double>(edge.frequency);
    double meanFrequency = edges.empty() ? 0.0 : totalFrequency / static_cast<double>(edges.size());

    // Filter edges with frequency >= meanFrequency
    std::vector<EdgeInfo> highFreqEdges;
    for (const auto& edge : edges) {
        if (static_cast<double>(edge.frequency) >= meanFrequency)
            highFreqEdges.push_back(edge);
    }

    if (highFreqEdges.empty()) {
        std::cerr << "No edges above frequency threshold. Returning empty Steiner Tree." << std::endl;
        return {};
    }

    // Sort high-frequency edges by weight ascending
    std::sort(highFreqEdges.begin(), highFreqEdges.end(), [](const EdgeInfo& a, const EdgeInfo& b) {
        return a.weight < b.weight;
    });

    // Initialize Union-Find structure
    std::vector<int> parentUF(n);
    std::iota(parentUF.begin(), parentUF.end(), 0);

    auto find_set = [&](int u) -> int {
        while (parentUF[u] != u)
            u = parentUF[u];
        return u;
    };

    auto unite_set = [&](int u, int v) {
        parentUF[find_set(u)] = find_set(v);
    };

    // Initialize graph from selected edges
    std::unordered_map<int, std::vector<int>> selectedGraph;

    // Add high-frequency edges
    for (const auto& edge : highFreqEdges) {
        int u = edge.vertexA;
        int v = edge.vertexB;
        if (find_set(u) != find_set(v)) {
            unite_set(u, v);
            selectedGraph[u].push_back(v);
            selectedGraph[v].push_back(u);
        }

        // Check if all terminals are connected
        int parentTerminal = find_set(*terminalVertices.begin());
        bool allConnected = std::all_of(terminalVertices.begin(), terminalVertices.end(), [&](int t) {
            return find_set(t) == parentTerminal;
        });
        if (allConnected) break;
    }

    // If not all terminals are connected, add lower-frequency edges
    int parentTerminalCheck = find_set(*terminalVertices.begin());
    bool connected = std::all_of(terminalVertices.begin(), terminalVertices.end(), [&](int t) {
        return find_set(t) == parentTerminalCheck;
    });

    if (!connected) {
        // Collect lower-frequency edges
        std::vector<EdgeInfo> lowerFreqEdges;
        for (const auto& edge : edges) {
            if (static_cast<double>(edge.frequency) < meanFrequency)
                lowerFreqEdges.push_back(edge);
        }

        // Sort lower-frequency edges by weight ascending
        std::sort(lowerFreqEdges.begin(), lowerFreqEdges.end(), [](const EdgeInfo& a, const EdgeInfo& b) {
            return a.weight < b.weight;
        });

        // Add lower-frequency edges
        for (const auto& edge : lowerFreqEdges) {
            int u = edge.vertexA;
            int v = edge.vertexB;
            if (find_set(u) != find_set(v)) {
                unite_set(u, v);
                selectedGraph[u].push_back(v);
                selectedGraph[v].push_back(u);
            }

            // Check if all terminals are connected
            int parentTerm = find_set(*terminalVertices.begin());
            bool allConn = std::all_of(terminalVertices.begin(), terminalVertices.end(), [&](int t) {
                return find_set(t) == parentTerm;
            });
            if (allConn) break;
        }
    }

    // Final connectivity check
    parentTerminalCheck = find_set(*terminalVertices.begin());
    connected = std::all_of(terminalVertices.begin(), terminalVertices.end(), [&](int t) {
        return find_set(t) == parentTerminalCheck;
    });

    if (!connected) {
        std::cerr << "Unable to connect all terminal vertices. Returning empty Steiner Tree." << std::endl;
        return {};
    }

    // Extract a valid path using BFS to ensure all edges are valid
    int start = *terminalVertices.begin();
    std::vector<int> path = findValidPath(selectedGraph, start);

    if (path.empty()) {
        std::cerr << "Failed to extract a valid path from the Steiner Tree." << std::endl;
        return {};
    }

    // Compute total distance
    double totalDistance = 0.0;
    for (size_t i = 0; i < path.size() - 1; ++i) {
        int u = path[i];
        int v = path[i + 1];
        // Find the edge in the edge list to get its weight
        auto it = std::find_if(edges.begin(), edges.end(), [&](const EdgeInfo& e) {
            return (e.vertexA == u && e.vertexB == v) ||
                   (e.vertexA == v && e.vertexB == u);
        });
        if (it != edges.end()) {
            totalDistance += it->weight;
        } else {
            // This should not happen as we built the graph from existing edges
            std::cerr << "Edge (" << u << ", " << v << ") not found in edge list." << std::endl;
        }
    }

    return {path, totalDistance};
}

//////////////////////////////////////////////////////////
// Helper Function to Find a Valid Path Using BFS
//////////////////////////////////////////////////////////

std::vector<int> WOCAlgorithm::findValidPath(const std::unordered_map<int, std::vector<int>>& graph, int start) {
    std::vector<int> path;
    std::unordered_set<int> visited;
    std::queue<int> q;
    std::unordered_map<int, int> parentMap; // To reconstruct the path

    q.push(start);
    visited.insert(start);

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        path.push_back(current);

        for (int neighbor : graph.at(current)) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                parentMap[neighbor] = current;
                q.push(neighbor);
            }
        }
    }

    // Reconstruct the path to include all terminals
    std::vector<int> finalPath;
    std::unordered_set<int> includedTerminals = terminalVertices;

    for (int terminal : includedTerminals) {
        if (terminal == start) continue;
        if (parentMap.find(terminal) == parentMap.end()) {
            std::cerr << "Terminal " << terminal << " is not reachable from " << start << "." << std::endl;
            continue;
        }

        // Reconstruct path from terminal to start
        std::vector<int> tempPath;
        int current = terminal;
        while (current != start) {
            tempPath.push_back(current);
            current = parentMap[current];
        }
        tempPath.push_back(start);
        std::reverse(tempPath.begin(), tempPath.end());

        // Append to finalPath without duplicating vertices
        for (int vertex : tempPath) {
            if (finalPath.empty() || finalPath.back() != vertex) {
                finalPath.push_back(vertex);
            }
        }
    }

    return finalPath;
}

// graphVisualizer.cpp
// Created by LuisF on 11/14/2024.

#include "graphVisualizer.h"
#include "globalData.h"
#include "geneticAlgorithm.h"
#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include "implot.h"
#include <GLFW/glfw3.h>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <numeric>

void graphVisualizer::displayPlot(SteinerTree steinerTree, SteinerTree wocTree) {
    // Initialize GLFW
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW.\n";
        return;
    }

    // Configure GLFW
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);

    // Create window
    GLFWwindow* window = glfwCreateWindow(1280, 720, "Graph Visualization", NULL, NULL);
    if (!window) {
        std::cerr << "Failed to create GLFW window.\n";
        glfwTerminate();
        return;
    }
    glfwMakeContextCurrent(window);

    // Initialize ImGui and ImPlot
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImPlot::CreateContext();
    ImGuiIO& io = ImGui::GetIO();

    // Setup ImGui style
    ImGui::StyleColorsDark();

    // Initialize ImGui backends
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 130");

    SteinerTree randomPath = steinerTree;

    // Prepare data for plotting vertices
    std::vector<double> vertexX;
    std::vector<double> vertexY;

    for (const auto& vertex : vertices) {
        vertexX.push_back(vertex[1]);
        vertexY.push_back(vertex[2]);
    }

    // Prepare data for plotting edges
    std::vector<std::pair<double, double>> edgePointsA;
    std::vector<std::pair<double, double>> edgePointsB;

    for (const auto& edge : edges) {
        double x1 = vertices[edge.vertexA][1];
        double y1 = vertices[edge.vertexA][2];
        double x2 = vertices[edge.vertexB][1];
        double y2 = vertices[edge.vertexB][2];
        edgePointsA.push_back({ x1, y1 });
        edgePointsB.push_back({ x2, y2 });
    }

    // Prepare data for Steiner Path
    std::vector<std::pair<double, double>> steinerEdgePointsA;
    std::vector<std::pair<double, double>> steinerEdgePointsB;
    for (size_t i = 0; i < randomPath.path.size() - 1; ++i) {
        int from = randomPath.path[i];
        int to = randomPath.path[i + 1];
        double x1 = vertices[from][1];
        double y1 = vertices[from][2];
        double x2 = vertices[to][1];
        double y2 = vertices[to][2];
        steinerEdgePointsA.push_back({ x1, y1 });
        steinerEdgePointsB.push_back({ x2, y2 });
    }

    // Prepare data for WOC Path
    std::vector<std::pair<double, double>> wocEdgePointsA;
    std::vector<std::pair<double, double>> wocEdgePointsB;
    for (size_t i = 0; i < wocTree.path.size() - 1; ++i) {
        int from = wocTree.path[i];
        int to = wocTree.path[i + 1];
        double x1 = vertices[from][1];
        double y1 = vertices[from][2];
        double x2 = vertices[to][1];
        double y2 = vertices[to][2];
        wocEdgePointsA.push_back({ x1, y1 });
        wocEdgePointsB.push_back({ x2, y2 });
    }

    // Prepare data for Average Distances over Generations
    std::vector<double> generations(avgDistanceOverGenerations.size());
    for (size_t i = 0; i < avgDistanceOverGenerations.size(); ++i) {
        generations[i] = static_cast<double>(i + 1); // Start from 1
    }

    // Main loop
    while (!glfwWindowShouldClose(window)) {
        // Poll events
        glfwPollEvents();

        // Start new ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();

        // Create ImGui window
        ImGui::Begin("Graph Visualization");

        if (ImGui::BeginTabBar("TabBar")) {
            //-----------------------------------------------------------------------------
            // NEW TAB 1 - Graph
            //-----------------------------------------------------------------------------
            if (ImGui::BeginTabItem("Graph")) {
                // Separate terminal and normal vertices
                std::vector<double> terminalX, terminalY;
                std::vector<double> normalX, normalY;

                for (const auto& vertex : vertices) {
                    if (vertex[3] == 1.0) { // Terminal vertex
                        terminalX.push_back(vertex[1]);
                        terminalY.push_back(vertex[2]);
                    } else { // Normal vertex
                        normalX.push_back(vertex[1]);
                        normalY.push_back(vertex[2]);
                    }
                }

                // Begin plot
                if (ImPlot::BeginPlot("Graph", ImVec2(-1, -1), 0)) {
                    // Compute dynamic axis limits
                    std::vector<double> allX;
                    std::vector<double> allY;
                    for (const auto& point : edgePointsA) {
                        allX.push_back(point.first);
                        allY.push_back(point.second);
                    }
                    for (const auto& point : edgePointsB) {
                        allX.push_back(point.first);
                        allY.push_back(point.second);
                    }

                    double minX = *std::min_element(allX.begin(), allX.end());
                    double maxX = *std::max_element(allX.begin(), allX.end());
                    double minY = *std::min_element(allY.begin(), allY.end());
                    double maxY = *std::max_element(allY.begin(), allY.end());

                    // Add padding
                    double paddingX = (maxX - minX) * 0.05; // 5% padding
                    double paddingY = (maxY - minY) * 0.05; // 5% padding

                    // Set up axes with padding
                    ImPlot::SetupAxes("X Coordinate", "Y Coordinate", 0, 0);
                    ImPlot::SetupAxisLimits(ImAxis_X1, minX - paddingX, maxX + paddingX, ImGuiCond_Always);
                    ImPlot::SetupAxisLimits(ImAxis_Y1, minY - paddingY, maxY + paddingY, ImGuiCond_Always);

                    // Plot edges as lines
                    ImPlot::PushStyleColor(ImPlotCol_Line, ImVec4(0.4f, 0.6f, 0.9f, 1.0f)); // Blue color
                    for (size_t i = 0; i < edgePointsA.size(); ++i) {
                        double xs[2] = { edgePointsA[i].first, edgePointsB[i].first };
                        double ys[2] = { edgePointsA[i].second, edgePointsB[i].second };
                        ImPlot::PlotLine("Edges", xs, ys, 2);
                    }
                    ImPlot::PopStyleColor();

                    // Plot normal vertices as scatter points
                    ImPlot::PushStyleColor(ImPlotCol_MarkerFill, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));  // Blue
                    ImPlot::PushStyleColor(ImPlotCol_MarkerOutline, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));  // Blue
                    ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle, 5.0f);
                    ImPlot::PlotScatter("Vertices", normalX.data(), normalY.data(), normalX.size());
                    ImPlot::PopStyleColor(2);

                    // Plot terminal vertices as scatter points
                    ImPlot::PushStyleColor(ImPlotCol_MarkerFill, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));  // Red
                    ImPlot::PushStyleColor(ImPlotCol_MarkerOutline, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));  // Red
                    ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle, 5.0f);
                    ImPlot::PlotScatter("Terminal Vertices", terminalX.data(), terminalY.data(), terminalX.size());
                    ImPlot::PopStyleColor(2);

                    // Annotate all vertices with their indices
                    for (size_t i = 0; i < vertices.size(); ++i) {
                        double x = vertices[i][1];
                        double y = vertices[i][2];
                        // Adjust offset for better visibility
                        ImVec2 offset(5, 5); // Adjust as needed
                        // Set text color
                        ImVec4 textColor = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);  // Black
                        // Annotate the vertex with its index
                        ImPlot::Annotation(
                                x, y,                   // Data coordinates
                                textColor,              // Text color
                                offset,                 // Pixel offset from the data point
                                true,                   // Clamp annotation within plot area
                                "%zu", i                // Format string to display the vertex index
                        );
                    }

                    ImPlot::EndPlot();
                }
                ImGui::EndTabItem();
            }

            //-----------------------------------------------------------------------------
            // TAB 2 - Steiner Tree
            //-----------------------------------------------------------------------------
            if (ImGui::BeginTabItem("Steiner Tree")) {
                // Code is similar to previous "Graph" tab, but includes the Steiner Path
                // Separate terminal and normal vertices
                std::vector<double> terminalX, terminalY;
                std::vector<double> normalX, normalY;

                for (const auto& vertex : vertices) {
                    if (vertex[3] == 1.0) { // Terminal vertex
                        terminalX.push_back(vertex[1]);
                        terminalY.push_back(vertex[2]);
                    } else { // Normal vertex
                        normalX.push_back(vertex[1]);
                        normalY.push_back(vertex[2]);
                    }
                }

                // Begin plot
                if (ImPlot::BeginPlot("Steiner Tree", ImVec2(-1, -1), 0)) {
                    // Compute dynamic axis limits
                    std::vector<double> allX;
                    std::vector<double> allY;
                    for (const auto& point : edgePointsA) {
                        allX.push_back(point.first);
                        allY.push_back(point.second);
                    }
                    for (const auto& point : edgePointsB) {
                        allX.push_back(point.first);
                        allY.push_back(point.second);
                    }

                    double minX = *std::min_element(allX.begin(), allX.end());
                    double maxX = *std::max_element(allX.begin(), allX.end());
                    double minY = *std::min_element(allY.begin(), allY.end());
                    double maxY = *std::max_element(allY.begin(), allY.end());

                    // Add padding
                    double paddingX = (maxX - minX) * 0.05; // 5% padding
                    double paddingY = (maxY - minY) * 0.05; // 5% padding

                    // Set up axes with padding
                    ImPlot::SetupAxes("X Coordinate", "Y Coordinate", 0, 0);
                    ImPlot::SetupAxisLimits(ImAxis_X1, minX - paddingX, maxX + paddingX, ImGuiCond_Always);
                    ImPlot::SetupAxisLimits(ImAxis_Y1, minY - paddingY, maxY + paddingY, ImGuiCond_Always);

                    // Plot edges as lines
                    ImPlot::PushStyleColor(ImPlotCol_Line, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));
                    for (size_t i = 0; i < edgePointsA.size(); ++i) {
                        double xs[2] = { edgePointsA[i].first, edgePointsB[i].first };
                        double ys[2] = { edgePointsA[i].second, edgePointsB[i].second };
                        ImPlot::PlotLine("Edges", xs, ys, 2);
                    }
                    ImPlot::PopStyleColor();

                    // Plot normal vertices as scatter points
                    ImPlot::PushStyleColor(ImPlotCol_MarkerFill, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));  // Blue
                    ImPlot::PushStyleColor(ImPlotCol_MarkerOutline, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));  // Blue
                    ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle, 5.0f);
                    ImPlot::PlotScatter("Vertices", normalX.data(), normalY.data(), normalX.size());
                    ImPlot::PopStyleColor(2);

                    // Plot terminal vertices as scatter points
                    ImPlot::PushStyleColor(ImPlotCol_MarkerFill, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));  // Red
                    ImPlot::PushStyleColor(ImPlotCol_MarkerOutline, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));  // Red
                    ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle, 5.0f);
                    ImPlot::PlotScatter("Terminal Vertices", terminalX.data(), terminalY.data(), terminalX.size());
                    ImPlot::PopStyleColor(2);

                    // Annotate all vertices with their indices
                    for (size_t i = 0; i < vertices.size(); ++i) {
                        double x = vertices[i][1];
                        double y = vertices[i][2];
                        // Adjust offset for better visibility
                        ImVec2 offset(5, 5); // Adjust as needed
                        // Set text color
                        ImVec4 textColor = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);  // Black
                        // Annotate the vertex with its index
                        ImPlot::Annotation(
                                x, y,                   // Data coordinates
                                textColor,              // Text color
                                offset,                 // Pixel offset from the data point
                                true,                   // Clamp annotation within plot area
                                "%zu", i                // Format string to display the vertex index
                        );
                    }

                    // Plot Steiner Path edges as red lines
                    if (!randomPath.path.empty()) {
                        ImPlot::PushStyleColor(ImPlotCol_Line, ImVec4(0.8f, 0.2f, 0.2f, 1.0f)); // Red color
                        for (size_t i = 0; i < steinerEdgePointsA.size(); ++i) {
                            double xs[2] = { steinerEdgePointsA[i].first, steinerEdgePointsB[i].first };
                            double ys[2] = { steinerEdgePointsA[i].second, steinerEdgePointsB[i].second };
                            ImPlot::PlotLine("Steiner Path", xs, ys, 2);
                        }
                        ImPlot::PopStyleColor();
                    }

                    ImPlot::EndPlot();
                }
                ImGui::EndTabItem();
            }
        //-----------------------------------------------------------------------------
        // TAB 3 - WOC Tree
        //-----------------------------------------------------------------------------
            if (ImGui::BeginTabItem("WOC Tree")) {
                // Separate terminal and normal vertices
                std::vector<double> terminalX, terminalY;
                std::vector<double> normalX, normalY;

                for (const auto& vertex : vertices) {
                    if (vertex[3] == 1.0) { // Terminal vertex
                        terminalX.push_back(vertex[1]);
                        terminalY.push_back(vertex[2]);
                    } else { // Normal vertex
                        normalX.push_back(vertex[1]);
                        normalY.push_back(vertex[2]);
                    }
                }

                // Begin plot
                if (ImPlot::BeginPlot("WOC Tree", ImVec2(-1, -1), 0)) {
                    // Compute dynamic axis limits
                    std::vector<double> allX;
                    std::vector<double> allY;
                    for (const auto& point : edgePointsA) {
                        allX.push_back(point.first);
                        allY.push_back(point.second);
                    }
                    for (const auto& point : edgePointsB) {
                        allX.push_back(point.first);
                        allY.push_back(point.second);
                    }

                    double minX = *std::min_element(allX.begin(), allX.end());
                    double maxX = *std::max_element(allX.begin(), allX.end());
                    double minY = *std::min_element(allY.begin(), allY.end());
                    double maxY = *std::max_element(allY.begin(), allY.end());

                    // Add padding
                    double paddingX = (maxX - minX) * 0.05; // 5% padding
                    double paddingY = (maxY - minY) * 0.05; // 5% padding

                    // Set up axes with padding
                    ImPlot::SetupAxes("X Coordinate", "Y Coordinate", 0, 0);
                    ImPlot::SetupAxisLimits(ImAxis_X1, minX - paddingX, maxX + paddingX, ImGuiCond_Always);
                    ImPlot::SetupAxisLimits(ImAxis_Y1, minY - paddingY, maxY + paddingY, ImGuiCond_Always);

                    // Plot edges as lines
                    ImPlot::PushStyleColor(ImPlotCol_Line, ImVec4(0.4f, 0.6f, 0.9f, 1.0f)); // Blue color
                    for (size_t i = 0; i < edgePointsA.size(); ++i) {
                        double xs[2] = { edgePointsA[i].first, edgePointsB[i].first };
                        double ys[2] = { edgePointsA[i].second, edgePointsB[i].second };
                        ImPlot::PlotLine("Edges", xs, ys, 2);
                    }
                    ImPlot::PopStyleColor();

                    // Plot normal vertices as scatter points
                    ImPlot::PushStyleColor(ImPlotCol_MarkerFill, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));  // Blue
                    ImPlot::PushStyleColor(ImPlotCol_MarkerOutline, ImVec4(0.4f, 0.6f, 0.9f, 1.0f));  // Blue
                    ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle, 5.0f);
                    ImPlot::PlotScatter("Vertices", normalX.data(), normalY.data(), normalX.size());
                    ImPlot::PopStyleColor(2);

                    // Plot terminal vertices as scatter points
                    ImPlot::PushStyleColor(ImPlotCol_MarkerFill, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));  // Red
                    ImPlot::PushStyleColor(ImPlotCol_MarkerOutline, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));  // Red
                    ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle, 5.0f);
                    ImPlot::PlotScatter("Terminal Vertices", terminalX.data(), terminalY.data(), terminalX.size());
                    ImPlot::PopStyleColor(2);

                    // Annotate all vertices with their indices
                    for (size_t i = 0; i < vertices.size(); ++i) {
                        double x = vertices[i][1];
                        double y = vertices[i][2];
                        // Adjust offset for better visibility
                        ImVec2 offset(5, 5); // Adjust as needed
                        // Set text color
                        ImVec4 textColor = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);  // Black
                        // Annotate the vertex with its index
                        ImPlot::Annotation(
                                x, y,                   // Data coordinates
                                textColor,              // Text color
                                offset,                 // Pixel offset from the data point
                                true,                   // Clamp annotation within plot area
                                "%zu", i                // Format string to display the vertex index
                        );
                    }

                    // Plot WOC Path edges as green lines
                    if (!wocTree.path.empty()) {
                        ImPlot::PushStyleColor(ImPlotCol_Line, ImVec4(0.2f, 0.8f, 0.2f, 1.0f)); // Green color
                        for (size_t i = 0; i < wocEdgePointsA.size(); ++i) {
                            double xs[2] = { wocEdgePointsA[i].first, wocEdgePointsB[i].first };
                            double ys[2] = { wocEdgePointsA[i].second, wocEdgePointsB[i].second };
                            ImPlot::PlotLine("WOC Path", xs, ys, 2);
                        }
                        ImPlot::PopStyleColor();
                    }

                    ImPlot::EndPlot();
                }
                ImGui::EndTabItem();
            }

            //-----------------------------------------------------------------------------
            // TAB 4 - Average Distances
            //-----------------------------------------------------------------------------
            if (ImGui::BeginTabItem("Average Distances")) {
                // Begin plot
                if (ImPlot::BeginPlot("Average Distance Over Generations", ImVec2(-1, -1), 0)) {
                    // Set up axes
                    ImPlot::SetupAxes("Generation", "Average Total Distance", 0, 0);

                    // Compute axis limits with padding
                    double min_gen = 1.0;
                    double max_gen = static_cast<double>(generations.size());
                    double min_dist = *std::min_element(avgDistanceOverGenerations.begin(), avgDistanceOverGenerations.end());
                    double max_dist = *std::max_element(avgDistanceOverGenerations.begin(), avgDistanceOverGenerations.end());

                    double padding_gen = (max_gen - min_gen) * 0.05; // 5% padding
                    double padding_dist = (max_dist - min_dist) * 0.05; // 5% padding

                    // Set axis limits with padding
                    ImPlot::SetupAxisLimits(ImAxis_X1, min_gen - padding_gen, max_gen + padding_gen, ImGuiCond_Always);
                    ImPlot::SetupAxisLimits(ImAxis_Y1, min_dist - padding_dist, max_dist + padding_dist, ImGuiCond_Always);

                    // Add legend
                    ImPlot::SetupLegend(ImPlotLocation_NorthEast);

                    // Plot the average distance over generations
                    ImPlot::PlotLine("Avg Distance", generations.data(), avgDistanceOverGenerations.data(), avgDistanceOverGenerations.size());

                    ImPlot::EndPlot();
                }
                ImGui::EndTabItem();
            }

            ImGui::EndTabBar();
        }
        ImGui::End();

        // Rendering
        ImGui::Render();
        int display_w, display_h;
        glfwGetFramebufferSize(window, &display_w, &display_h);
#ifdef __APPLE__
        glViewport(0, 0, display_w, display_h);
#else
        glViewport(0, 0, display_w, display_h);
#endif
        glClearColor(0.45f, 0.55f, 0.60f, 1.00f);
        glClear(GL_COLOR_BUFFER_BIT);

        // Render ImGui draw data
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        // Swap buffers
        glfwSwapBuffers(window);
    }

    // Cleanup
    ImPlot::DestroyContext();
    ImGui::DestroyContext();
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    glfwDestroyWindow(window);
    glfwTerminate();
}
//
// Created by LuisF
//

#include "common.h"
#include "globalData.h"
#include <iostream>
#include <algorithm>
#include <execution>
#include "cmath"
#include <queue>


Timer::Timer() : running(false) {}

void Timer::start() {
    startTime = std::chrono::high_resolution_clock::now();
    running = true;
}

void Timer::stop() {
    if (running) {
        endTime = std::chrono::high_resolution_clock::now();
        running = false;
    }
}

double Timer::elapsedMilliseconds() const {
    if (running) {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
    } else {
        return std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    }
}

double Timer::elapsedSeconds() const {
    return elapsedMilliseconds() / 1000.0;
}

void printVector(const std::vector<int>& vec) {
    for (std::size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << " -> ";
        }
    }
    std::cout << std::endl;
}

// Function to print a SteinerTree
void printSteinerTree(const SteinerTree& tree) {
    // Print the path
    std::cout << "Path: ";
    for (std::size_t i = 0; i < tree.path.size(); ++i) {
        std::cout << tree.path[i];
        if (i < tree.path.size() - 1) {
            std::cout << " -> ";
        }
    }

    // Print the total distance with fixed precision
    std::cout << "\nTotal Distance: " << tree.totalDistance << std::endl;
}

void printEdges() {
    for (const auto& edge : edges) {
        std::cout << "edge: (" << edge.vertexA << ", " << edge.vertexB << "), weight: " << edge.weight << ", frequency: " << edge.frequency << std::endl;
    }
}


double computeTotalDistance(const std::vector<int> &path) {
    double totalDistance = 0.0;
    for (size_t i = 1; i < path.size(); ++i) {
        int u = path[i - 1];
        int v = path[i];
        bool edgeFound = false;

        // Search for the edge between u and v
        for (const auto& edge : edges) {
            if ((edge.vertexA == u && edge.vertexB == v) || (edge.vertexA == v && edge.vertexB == u)) {
                totalDistance += edge.weight;
                edgeFound = true;
                break;
            }
        }

        // If edge not found in the edges list, compute Euclidean distance
        if (!edgeFound) {
            double dx = vertices[u][1] - vertices[v][1];
            double dy = vertices[u][2] - vertices[v][2];
            double dist = std::sqrt(dx * dx + dy * dy);
            totalDistance += dist;
        }
    }
    return totalDistance;
}

double computeTotalDistanceOfPopulation(const std::vector<SteinerTree>& population) {
    double totalPopulationDistance = 0.0;

    // Iterate over each SteinerTree in the population
    for (const SteinerTree& tree : population) {
        totalPopulationDistance += computeTotalDistance(tree.path); // Use the path from each SteinerTree
    }

    return totalPopulationDistance; // Return the total distance for the population
}

// Function to increment the frequency of edges used in a vector of Steiner Trees
void incrementEdgeFrequencies(const std::vector<SteinerTree>& trees) {
    // Create a map from edge key to index in the edges vector for quick lookup
    std::unordered_map<std::string, int> edgeKeyToIndex;
    for (size_t i = 0; i < edges.size(); ++i) {
        int u = edges[i].vertexA;
        int v = edges[i].vertexB;
        std::string key = (u < v) ? std::to_string(u) + "-" + std::to_string(v)
                                  : std::to_string(v) + "-" + std::to_string(u);
        edgeKeyToIndex[key] = static_cast<int>(i);
    }

    // Iterate over each tree in the vector
    for (const auto& tree : trees) {
        const std::vector<int>& path = tree.path; // The sequence of vertices in the tree

        // Increment frequency for each edge in the tree's path
        for (size_t i = 0; i + 1 < path.size(); ++i) {
            int u = path[i];
            int v = path[i + 1];
            std::string key = (u < v) ? std::to_string(u) + "-" + std::to_string(v)
                                      : std::to_string(v) + "-" + std::to_string(u);

            auto it = edgeKeyToIndex.find(key);
            if (it != edgeKeyToIndex.end()) {
                int idx = it->second;
                edges[idx].frequency += 1; // Increment the frequency of the edge
            }
        }
    }
}

// Helper function to check if an edge exists between two nodes
bool edgeExists(int u, int v) {
    for (const auto& edge : edges) {
        if ((edge.vertexA == u && edge.vertexB == v) || (edge.vertexA == v && edge.vertexB == u)) {
            return true;
        }
    }
    return false;
}

// Function to find a path between two nodes using BFS
std::vector<int> findPath(int start, int end) {
    std::queue<std::vector<int>> q;
    std::unordered_set<int> visited;
    q.push({start});
    visited.insert(start);

    while (!q.empty()) {
        std::vector<int> currentPath = q.front();
        q.pop();
        int currentNode = currentPath.back();

        if (currentNode == end) {
            return currentPath;
        }

        for (const auto& edge : edges) {
            int neighbor = -1;
            if (edge.vertexA == currentNode) {
                neighbor = edge.vertexB;
            } else if (edge.vertexB == currentNode) {
                neighbor = edge.vertexA;
            }
            if (neighbor != -1 && visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                std::vector<int> newPath = currentPath;
                newPath.push_back(neighbor);
                q.push(newPath);
            }
        }
    }
    // No path found
    return {};
}

// Function to find the closest node in the path to the given terminal
int findClosestNode(int terminal, const std::vector<int>& path) {
    double minDistance = std::numeric_limits<double>::max();
    int closestNode = -1;
    for (int node : path) {
        double dx = vertices[node][1] - vertices[terminal][1];
        double dy = vertices[node][2] - vertices[terminal][2];
        double dist = std::sqrt(dx * dx + dy * dy);
        if (dist < minDistance) {
            minDistance = dist;
            closestNode = node;
        }
    }
    return closestNode;
}

// Repair function to ensure path validity
std::vector<int> repairPath(const std::vector<int>& path) {
    std::unordered_set<int> visited;
    std::vector<int> repairedPath;
    int previousNode = -1;

    for (int node : path) {
        if (visited.find(node) == visited.end()) {
            // Ensure the edge between previousNode and node exists
            if (previousNode != -1 && !edgeExists(previousNode, node)) {
                // Find a path between previousNode and node
                std::vector<int> connectingPath = findPath(previousNode, node);
                if (!connectingPath.empty()) {
                    // Exclude the starting node to avoid duplication
                    repairedPath.insert(repairedPath.end(), connectingPath.begin() + 1, connectingPath.end());
                }
            } else {
                repairedPath.push_back(node);
            }
            visited.insert(node);
            previousNode = node;
        }
    }

    // Ensure all terminal vertices are included
    for (int terminal : terminalVertices) {
        if (visited.find(terminal) == visited.end()) {
            // Find the closest node in repairedPath
            int closestNode = findClosestNode(terminal, repairedPath);
            // Find a path to connect the terminal
            std::vector<int> connectingPath = findPath(closestNode, terminal);
            if (!connectingPath.empty()) {
                // Exclude the starting node to avoid duplication
                repairedPath.insert(repairedPath.end(), connectingPath.begin() + 1, connectingPath.end());
                visited.insert(terminal);
            }
        }
    }

    return repairedPath;
}

// Function to select top k Steiner Trees
std::vector<SteinerTree> selectTopK(std::vector<SteinerTree> &population) {
    size_t populationSize = population.size();
    size_t k = 0;

    // Calculate k based on population size
    if (populationSize > 500) {
        k = static_cast<size_t>(populationSize * 0.05); // 5% for population > 500
    } else if (populationSize > 250) {
        k = static_cast<size_t>(populationSize * 0.10); // 10% for 250 < population <= 500
    } else {
        k = static_cast<size_t>(populationSize * 0.15); // 15% for population <= 250
    }

    // Ensure k is at least 1 to avoid returning an empty vector
    k = std::max<size_t>(1, k);

    if (k >= populationSize) {
        // If k is larger than the population, return the whole population sorted
        std::sort(population.begin(), population.end(),
                  [](const SteinerTree& a, const SteinerTree& b) {
                      return a.totalDistance < b.totalDistance;
                  });
        return population;
    }

    // Partially sort the population to find the kth element
    std::nth_element(population.begin(), population.begin() + k, population.end(),
                     [](const SteinerTree& a, const SteinerTree& b) {
                         return a.totalDistance < b.totalDistance;
                     });

    // Extract the top k elements
    std::vector<SteinerTree> topK(population.begin(), population.begin() + k);

    // Optionally sort the top k elements if order matters
    std::sort(topK.begin(), topK.end(),
              [](const SteinerTree& a, const SteinerTree& b) {
                  return a.totalDistance < b.totalDistance;
              });

    return topK;
}



//
// Created by LuisF
//

#include "globalData.h"
int n = 0;
int numTerminals = 0;
std::vector<std::vector<double>> vertices;
std::vector<EdgeInfo> edges;
std::unordered_set<int> terminalVertices;
std::vector<double> avgDistanceOverGenerations;

//
// Created by LuisF on 11/14/2024.
//

#ifndef ESTPGENETICALGORITHMWOC_GLOBALDATA_H
#define ESTPGENETICALGORITHMWOC_GLOBALDATA_H


#include <vector>
#include "unordered_set"

struct EdgeInfo {
    int vertexA;
    int vertexB;
    double weight;
    int frequency;
};

// struct to store Steiner tree information
struct SteinerTree {
    std::vector<int> path;       // The sequence of vertices in the tree
    double totalDistance;        // Total distance of the tree
};


extern int n; // Number of vertices
extern int numTerminals;
extern std::vector<std::vector<double>> vertices; // [vertex number, x, y, terminal status]
extern std::vector<EdgeInfo> edges; // List of all edges with weights
extern std::unordered_set<int> terminalVertices; // Indices of terminal vertices
extern std::vector<double> avgDistanceOverGenerations; // The avg distance over a lot of time fr

#endif //ESTPGENETICALGORITHMWOC_GLOBALDATA_H


// randomWeightedGraph.cpp
// Created by LuisF on
#include "randomWeightedGraph.h"
#include "globalData.h" // Include the global variables
#include <iostream>
#include <cmath>
#include <random>
#include <algorithm>
#include <set>

randomWeightedGraph::randomWeightedGraph() {
}

void randomWeightedGraph::generateGraph() {
    //getUserInput();
    determineTerminalCount();
    generateVertices();
    generateEdges();
}

void randomWeightedGraph::getUserInput() {
    std::cout << "How many vertices would you like? ";
    std::cin >> n;
    if (n <= 0) {
        std::cerr << "Wrong input." << std::endl;
        exit(1);
    }
}

void randomWeightedGraph::determineTerminalCount() {
    std::random_device rd;
    std::mt19937 gen(rd());
    double minPercentage, maxPercentage;
    if (n <= 75) {
        minPercentage = 0.10;
        maxPercentage = 0.50;
    } else {
        minPercentage = 0.03;
        maxPercentage = 0.30;
    }
    std::uniform_real_distribution<> dis(minPercentage, maxPercentage);
    double percentage = dis(gen);
    numTerminals = static_cast<int>(std::round(n * percentage));
}

void randomWeightedGraph::generateVertices() {
    vertices.resize(n, std::vector<double>(4)); // [vertex number, x, y, terminal status]
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> coordDis(0.0, 100.0);
    std::vector<int> indices(n);
    for (int i = 0; i < n; ++i) indices[i] = i;
    std::shuffle(indices.begin(), indices.end(), gen);

    terminalVertices.clear();
    for (int i = 0; i < numTerminals; ++i) {
        terminalVertices.insert(indices[i]);
    }

    for (int i = 0; i < n; ++i) {
        vertices[i][0] = i; // vertex number
        vertices[i][1] = coordDis(gen); // x coordinate
        vertices[i][2] = coordDis(gen); // y coordinate
        vertices[i][3] = 0; // default to non-terminal
    }
    for (int idx : terminalVertices) {
        vertices[idx][3] = 1; // mark as terminal
    }
}

// Helper function to check if two edges intersect
bool randomWeightedGraph::edgesIntersect(int a1, int a2, int b1, int b2) {
    double x1 = vertices[a1][1], y1 = vertices[a1][2];
    double x2 = vertices[a2][1], y2 = vertices[a2][2];
    double x3 = vertices[b1][1], y3 = vertices[b1][2];
    double x4 = vertices[b2][1], y4 = vertices[b2][2];

    // Exclude shared vertices
    if (a1 == b1 || a1 == b2 || a2 == b1 || a2 == b2)
        return false;

    // Compute direction of the lines
    double denom = (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1);
    if (denom == 0) return false; // Lines are parallel

    double ua = ((x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3)) / denom;
    double ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3)) / denom;

    return (ua > 0 && ua < 1 && ub > 0 && ub < 1);
}

void randomWeightedGraph::generateEdges() {
    double additionalEdgePercentage = 0.30; // Adjust this value to change the percentage of additional edges

    edges.clear();

    std::random_device rd;
    std::mt19937 gen(rd());

    // Initialize Union-Find structure
    std::vector<int> parent(n);
    std::iota(parent.begin(), parent.end(), 0); // parent[i] = i

    auto find = [&](int u) {
        while (parent[u] != u)
            u = parent[u];
        return u;
    };

    auto unite = [&](int u, int v) {
        parent[find(u)] = find(v);
    };

    // Set to store existing edges with ordered pairs
    std::set<std::pair<int, int>> existingEdges;

    // Generate all possible edges without intersections
    std::vector<EdgeInfo> possibleEdges;

    for (int P = 0; P < n; ++P) {
        // Coordinates of P
        double Px = vertices[P][1];
        double Py = vertices[P][2];

        // Compute polar coordinates of other points relative to P
        std::vector<std::tuple<double, double, int>> polarCoords;
        for (int i = 0; i < n; ++i) {
            if (i == P) continue;
            double dx = vertices[i][1] - Px;
            double dy = vertices[i][2] - Py;
            double r = std::sqrt(dx * dx + dy * dy);
            double theta = std::atan2(dy, dx);
            if (theta < 0) theta += 2 * M_PI;
            polarCoords.emplace_back(theta, r, i);
        }

        // Sort points by angle
        std::sort(polarCoords.begin(), polarCoords.end());

        // For each point, check visibility
        for (const auto& [thetaC, rC, C] : polarCoords) {
            bool blocked = false;
            // Check against existing edges
            for (const auto& edge : edges) {
                int A = edge.vertexA;
                int B = edge.vertexB;
                if (A == P || B == P || A == C || B == C)
                    continue;

                if (edgesIntersect(P, C, A, B)) {
                    blocked = true;
                    break;
                }
            }
            if (!blocked) {
                double dx = vertices[P][1] - vertices[C][1];
                double dy = vertices[P][2] - vertices[C][2];
                double dist = std::sqrt(dx * dx + dy * dy);
                possibleEdges.push_back({P, C, dist});
            }
        }
    }

    // Sort possible edges by weight (optional)
    std::sort(possibleEdges.begin(), possibleEdges.end(), [](const EdgeInfo& a, const EdgeInfo& b) {
        return a.weight < b.weight;
    });

    // Kruskal's algorithm to ensure connectivity
    for (const auto& edge : possibleEdges) {
        int u = edge.vertexA;
        int v = edge.vertexB;
        if (find(u) != find(v)) {
            // Check if edge intersects existing edges
            bool intersects = false;
            for (const auto& existingEdge : edges) {
                if (edgesIntersect(u, v, existingEdge.vertexA, existingEdge.vertexB)) {
                    intersects = true;
                    break;
                }
            }
            if (!intersects) {
                edges.push_back(edge);
                unite(u, v);
                // Add edge to existingEdges set
                int a = u, b = v;
                if (a > b) std::swap(a, b);
                existingEdges.insert({a, b});
            }
        }
    }

    // Check if all vertices are connected
    int root = find(0);
    for (int i = 1; i < n; ++i) {
        if (find(i) != root) {
            // Try to connect the disconnected component
            for (int j = 0; j < n; ++j) {
                if (find(j) == root) {
                    double dx = vertices[i][1] - vertices[j][1];
                    double dy = vertices[i][2] - vertices[j][2];
                    double dist = std::sqrt(dx * dx + dy * dy);
                    EdgeInfo newEdge = {i, j, dist};

                    // Check if edge intersects existing edges
                    bool intersects = false;
                    for (const auto& existingEdge : edges) {
                        if (edgesIntersect(i, j, existingEdge.vertexA, existingEdge.vertexB)) {
                            intersects = true;
                            break;
                        }
                    }
                    if (!intersects) {
                        edges.push_back(newEdge);
                        unite(i, j);
                        // Add edge to existingEdges set
                        int a = i, b = j;
                        if (a > b) std::swap(a, b);
                        existingEdges.insert({a, b});
                        break;
                    }
                }
            }
            // Update root
            root = find(0);
        }
    }

    // **Add Additional Edges**

    int numExistingEdges = edges.size();
    int numAdditionalEdges = static_cast<int>(numExistingEdges * additionalEdgePercentage);

    // Prepare candidate edges
    std::vector<EdgeInfo> candidateEdges;

    // Shuffle possibleEdges for randomness
    std::vector<EdgeInfo> shuffledPossibleEdges = possibleEdges;
    std::shuffle(shuffledPossibleEdges.begin(), shuffledPossibleEdges.end(), gen);

    for (const auto& edge : shuffledPossibleEdges) {
        if (numAdditionalEdges <= 0)
            break;

        int u = edge.vertexA;
        int v = edge.vertexB;
        int a = u, b = v;
        if (a > b) std::swap(a, b);

        if (existingEdges.count({a, b}) == 0) {
            // Check if edge intersects existing edges
            bool intersects = false;
            for (const auto& existingEdge : edges) {
                if (edgesIntersect(u, v, existingEdge.vertexA, existingEdge.vertexB)) {
                    intersects = true;
                    break;
                }
            }
            if (!intersects) {
                edges.push_back(edge);
                existingEdges.insert({a, b});
                numAdditionalEdges--;
            }
        }
    }
}


